## Listing examples for a command
```powershell
Get-Help <COMMAND> -Examples 
#Getting parameter list  
Get-Help <COMMAND> -Parameter *
```
## List commands by type and function
- For example i want to know which command list the processes
```powershell
Get-Command -commandType cmdlet -name *process*
#You can pipe above command to 'Object-Measure' to print number of lines
Get-Command -commandType cmdlet -name *process* | Measure-Object
```
## Output Formats
```powershell
Get-Command -name out *  
Get-command -name format *
```
## Useful Operatores for Parsing
```powershell
"string" -replace "ing","aight"  #output -> straight
"string string string" -split " ",<number to split upon on>  
"welcome","zeyad" -join " "   #output -> welcome zeyad
```
## Difference between Double and single quotes
```powershell
$a = "hello"  
$b = "zeyad"  
"$a $b" #Prints -> hello zeyad  
'$a $b' #Prints -> $a $b
```
## Writing Multilines
```powershell
@" <press enter>  
<text>  
"@ <press enter>
```
## Get variable type
```powershell
$<var>.GetType()
```
## Arrays
```powershell
$a = 1 + 6.5  
[int]$a #Prints 8  
  
#Empty array  
$a = @()  
  
#Array with elements  
$a = 1,2,"ss",3  
  
#Print a specific element  
$a[0]
```
## Conditional statements
```powershell
#if Statement
if ( 1 -gt 0){"hello"} else {"not hello"}  
if (((Get-Process).count) -lt 50 ){"less than 50"} else {"more than 50"}

#Switch Statement
switch (1) { 1 {"you chose number one"} 2 {"you chose number two"} default {"default"}}  
switch -wildcard ('abc') { a* {"A"} *b* {"B"} c* {"C"}}
```
## Loop statements
```powershell
#For loop  
$s = Get-ChildItem  
foreach ($a in $s){"item is $a"} #prints the content of the current directory  
Get-Process | ForEach-Object {$_.ProcessName}  
Get-Process | ForEach-Object processname #Similar to the upper one  
  
#While loop  
$count = 0  
while ($count -lt 7){"item is : $count", $count++}   
  
#Where-object  
Get-ChildItem -Recurse C:\\ | Where-Object {$_.name -match "txt"}   
  
#Exercise getting the path for every process  
Get-Process | ForEach-Object {$_.path}
```
## Functions
```powershell
function add { 4 + 5 }  
add #calls the function and prints the answer  
  
#Using parameters  
function parameter { $args }  
parameter "hello" # calls the function and assignes "hello" to the $args (while $args is an array) then outputs "hello"  
  
function parameter { $args[0] + $args[1] }  
parameter 4 7 #Outputs the output from the adding  
  
#Passing parameters  
function add ($num1,$num2){$num1 + $num2}  
add 4 7   
  
#Positioning params  
function parameter ($param1,$param2){$param1}  
parameter -param2 5 -param1 4 #Prints 4  
  
#Identifying alot of params than defined in the function  
 function params ($p1,$p2){$p1,$p2,$args}  
params g g g #prints 3 g's  
  
#Using switch parameter  
 function switchable ($p1,$p2,[switch]$p3) {if ($p3){$p1 + $p2}}  
 switchable 1 2 #outputs notthing  
 switchable 1 2 -p3 #outputs 3   
#You can assign the function to a variable  
$output = switchable 1 2 -p3   
$output #Prints 3   
  
#Exerices: write a function that accept a process name,pid,service name then stop it   
function process-mon($proc,$serv,$procid,[switch]$stop_pd,[switch]$stop_ps,[switch]$stop_sv){if ($stop_ps){stop-process -name $proc}},{if ($stop_sv){stop-service -name $serv}},{if ($stop_pd){stop-process -id $procid}}  
#The above function needs fixing for the pid parameter to work
```
## Advanced Functions
```powershell
function advanced  
{  
    param (  
        [parameter (mandatory = $true , position = 0 , valuefrompipeline = $true)][AllowNull()][string]$a  #Mandatory   & position is for providing the position & and value frompipeline is for passing a value from a pipe |  
        ,  
        [parameter (position = 1)]$b  #If you provided a position attribute for one parameter you must provide it for the rest.  
        )  
write-output " a is $a"  
write-output " b is $b"  
}
```
## Advanced Scripting
```powershell
function advanced {  
    [cmdletbinding(SupportsShouldProcess=$true)]  
  
    param (  
        [parameter()]$filepath  
        )  
  
        Write-Verbose " Removing the $filepath "  #Works when i provide -verbose option with the script  
  
        if ($PSCmdlet.ShouldProcess("$filepath","Deleting the file permanently"))   #To specify a custom message when running the script  
        {Remove-Item $filepath}  
        }  
          
#Options when running the script :  
-whatif  
-verbose  
-<manymore>
```
## Enable remoting
```powershell
#You need to be in the administrative group in the remote machine and to be in the same domain   
    #OR  
#To be in a trusted workgroup #follow the below lines  
# -You need to put the host name/ip in the trustedhosts file after enabling the ps remoting
#NOTE -> Do the following for both machines
1- enable-psremoting  
2- set-item wsman:\localhost\client\trustedhosts -Value computername/ip  #it accepts regex
```
## Remoting
```powershell
#Commands with "computername" parameter can execute commnads remotley  
#TO get these commands  
Get-Command -Type cmdlet -ParameterName computername  
  
#You can execute a command on multiple hosts with a for loop statement or if using invoke-commnad just put a ',' between computer names (requires to be the admin for the domain those computers are in)  
invoke-command -scriptblock { command } -computername <value> -credentials pcname\username  
  
#To open a session   
enter-pssession -computername <name> -credentials pcname\username  
  
#You can save a session as a variable and invoke commnads to  
$sess = new-pssession <with its parameters>  
invoke-commnand ...... -session $sess
```
## Jobs
```powershell
start-job -scriptblock {}  
recieve-job #to get the output  
stop-job  
  
#running commands as jobs in remote computer  
invoke-commnad <parameters> -asjob  
  
#running commands in a specific session  
$sess = new-pssession <parameters>  
invoke-commnad <parameters> -session $sess