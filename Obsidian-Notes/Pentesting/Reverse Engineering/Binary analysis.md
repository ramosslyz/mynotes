# Binary analysis
---
## Navigation
- **[[#Symbols and stripped binaries]]**
- **[[#Disassembling a binary]]**
- **[[#ELF format]]**
	- [[#Executable header]]
	- [[#Section header]]
---
# Symbols and stripped binaries
## Symbolic information
High-level source code, such as C code, centers around functions and variables with meaningful, human-readable names. When compiling a program,compilers emit symbols, which keep track of such symbolic
names and record which binary code and data correspond to each symbol.
- Getting the main function address and size (bytes)
```bash
readelf --syms <Executable> | grep -i "main"
```
> **ELF binaries**, debugging symbols are typically generated in the DWARF format,5 while **PE binaries** usually use the proprietary...Microsoft Portable Debugging (PDB) format. DWARF information is usually embedded within the binary, while PDB comes in the form of a separate symbol file.
## Binary stripping
Unfortunately, extensive debugging information typically isn’t included
in production-ready binaries, and even basic symbolic information is often stripped to *reduce file sizes and prevent reverse engineering*, especially in the case of malware or proprietary software. This means that as a binary analyst, you often have to deal with the far more challenging case of stripped binaries without any form of symbolic information.
- Stripping a binary
```bash
strip --strip-all <Executable>
```
---
# Disassembling a binary
## Object files
- Disassembling an object file
```bash
#show the contents of the .rodata (read-only data) section
objdump -sj .rodata example.o

#disassembles in intel syntax 
objdump -M intel -d compilation_example.o
```
>**Data** and **code references** from object files are not yet fully resolved because the compiler doesn’t know at what base address the file will eventually be loaded. That's why the assembly code looks nonsensical.

You can confirm this by asking `readelf` to show you all the relocation symbols present in the object file.
```bash
readelf -relocs example.o
```
The relocation symbol tells the linker that it should resolve the reference to the string to point to whatever address it ends up at in the `.rodata` section.
## Complete binary executable
- Disassembling an executable with `objdump`
```bash
objdump -M intel -d <Executable>
```
> Although the different sections are clearly distinguishable in both stripped and non-stripped binaries, the stripped binary functions are not distinguishable.
---
# ELF format
**ELF binaries** really consist of only four types of components: an `executable header`, a series of (optional) `program headers`, a `number of sections`, and a series of (optional) `section headers`, one per section.
> You can find the definitions of ELF-related types and constants in `/usr/include/elf.h` .

![[ELF-format.png]]

## Executable header
Is just a structured series of bytes telling you that it’s an ELF file, what kind of ELF file it is, and where in the file to find all the other contents.
- **To read the ELF header**
```bash
readelf -h <excutalbe>
```
> Those headers are explained in details in `Practical binary analysis` book  page [33] ...
> And  in this link => [https://refspecs.linuxbase.org/elf/elf.pdf](https://refspecs.linuxbase.org/elf/elf.pdf)

## Section header
The code and data in an ELF binary are logically divided into contiguous non overlapping chunks called sections.
1. Sections don’t have any predetermined structure.
2. Often a section is nothing more than an unstructured blob of code or data. Every section is described by a section header.
3. Some sections contain data that isn’t needed for execution at all, such as symbolic or relocation information.
4. sections are intended to provide a view for the linker only, the
section header table is an optional part of the ELF format. ELF files that don’t need linking aren’t required to have a section header table. If no section header table is present, the e_shoff field in the executable header is set to zero.

- **To read the all sections of an ELF executable**
```bash 
readelf -S --wide <Executable>
```
### .init and .fini sections
The `.init` section contains executable code that performs initialization tasks and needs to run before any other code in
the binary is executed.The `.fini` section is analogous to the `.init` section, except that it runs after the main program completes, essentially functioning as a kind of destructor.

### .text section
Is where the main code of the program resides,so it will frequently be the main focus of your binary analysis or reverse engineering efforts.
, the .text section of a typical binary compiled by gcc contains a num-
ber of standard functions that perform initialization and finalization tasks, such as `_start`, `register_tm_clones`, and `frame_dummy`.
- **Disassembly of `_start` function**
```bash
objdump -M intel -d <executable>
```

### .bss, .data, and .rodata sections
Those are writable sections used to contain variable Because code sections are generally not writable.
> Modern versions of gcc and clang generally don’t mix code and data, but Visual Studio sometimes does.

- `.rodata` section, which stands for “read-only data,” is dedicated to storing constant values (Not writable section).
- `.data` default values of initialized variables are stored here.
- `.bss` section reserves space for uninitialized variables. The name historically stands for “block started by symbol,” referring to the reserving of blocks of memory for (symbolic) variables.

>Unlike **.rodata** and **.data**, which have type SHT_PROGBITS, the .bss section has type SHT_NOBITS. This is because .bss doesn’t occupy any bytes in the binary as it exists on disk—it’s simply a **directive to allocate a properly sized block of memory for uninitialized variables**when setting up an execution environment for the binary. Typically, variables that live in .bss are zero initialized, and the section is marked as writable.

### Lazy Binding and the .plt, .got, and .got.plt sections
#### Lazy Binding and the PLT
 **dynamic linker** is the part of an operating system that loads and links the shared libraries needed by an executable when it is executed  at run time(**Lazy binding**), by copying the content of libraries from persistent storage to RAM.
 - On Linux, lazy binding is the default behavior of the dynamic linker.
- Lazy binding in Linux ELF binaries is implemented with the help of two special sections, called the **Procedure Linkage Table** (.plt) and the **Global Offset Table** (.got)
 
 ![[calling a shared library via plt.png]]
 
 - Disassembly of a `.plt` section
```bash
objdump -M intel --section .plt -d <executable>
```

> `.got` is for references to data items, while `.got.plt` is dedicated to storing resolved addresses for library functions accessed via the PLT.
> Explained in details in page [46-47] in practical binary analysis book

## .rel and .rela sections
