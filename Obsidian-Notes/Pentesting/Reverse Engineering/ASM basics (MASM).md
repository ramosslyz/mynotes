# ASM basics
---
## Navigation

- **[[#Intel instructions]]**
- **[[#Basic data types]]**
	1. [[#Legacy data directives]]
	2. [[#Data definition statement]]
	3. [[#Defining BYTE SBYTE data]]
	4. [[#Defining Byte Arrays]]
	5. [[#Defining strings]]
- **[[#References]]**
---
# Basic elements
1. **[[#Integer constants and expressions]]**
2. **[[#Character and string]]**
3. **[[#Reserved words and identifiers]]**
4. **[[#Directives موجه]]**
5. **[[#Labels]]**
6. **[[#Mnemonic]]**

![[Nasm structure.png]]

## Integer constants and expressions.
- Optional leading `+` or `-` sign.
- Binary, Decimal, Hexadecimal.
- Common radix characters:
	- `h` => hexadecimal  (Use as much as possible)
	- `d` => Decimal  (When hex makes no sense)
	- `b` => Binary  (For bitwise clarity)
	- `r` => Encoded real  (Real)
**Examples:**
`30d`, `6Ah`, `42`, `1101b`

>**NOTE:** Hexadecimal can't begin with a letter. => 0A2h

### Expressions
As any programming language
```txt
(2*3) + 4/6
```
---
## Character and string
- **Enclose character in single or double quotes.**
	-  `'a'` , `"a"`  => (ASCII char == 1 byte).
- **Enclose strings in single or double quotes.**
	- `"Hello"` , `'Hello'` => (Each ASCII char == 1 byte).
- **Embedded quotes are allowed**
	- `'Say "Abuqasem" is learning'`
	- `"This isn't  a test"`

> **NOTE:**
> Each string must end with a  '0' to tell the function to print until the zero.
> => "Hello world",0 (old assemblers used '$' instead of zero)

---
## Reserved words and  identifiers
- **Reserved words cannot be used as identifiers.**
	- Instruction mnemonics, directives,  type attributes, operators, predefined symbols.
- **Identifiers**
	- 1-247 chars, including digits.
	- Not case sensitive.
	- First character must be a letter. => (`_`, `@`, `?`, `$`)
	- Used for labels (Procedure names, variables, constants).
---
## Directives (موجه)
- **Instructions on how to assemble (Not at runtime).**
- **Commands that are recognized ad acted upon by the assembler.**
	- Not part of the intel instruction set.
	- Used to declare code , data areas, select memory model, declare procedures, variables etc..
	- Not case sensitive (.data,.DATA,.DAta).
- **Different assemblers have different directives**
	- GNU , netwide are not the same as MASM.
- **One important function of assembler directives is to define program sections, or segments**
	- .data (define variables)
	- .code (write code)
	- .stack 100h
 ---
 ## Labels
 - **Act as a place markers**
 	- Marks the address (offset) of code ad data.
 - **Follow identifier rules**
 - **Data label (Variable names)**
 	- Must be unique.
 	- `count DWORD 100` => (not followed by a colon)
 - **Code label**
 	- Target of jump and loop instructions.
 	- `L1:`  => (Followed by a colon)
 --- 
 ## Mnemonic
 - **No operands**
 	- `stc` => (set carry flag)
 - **One operand**
 	- `inc eax` => (register)
 	- `inc myByte` => (memory)
 - **Two operands**
 	- `add ebx,ecx` => (register, register)
 	- `sub myByte,25` => (memory, constant)
 	- `add eax,36 * 25` => (register, const-expr)

### NOP instruction
- No Operation.
- Uses 1 byte of storage.
- CPU: Reads it, Decodes it, ignores it.
- Used to allign code to even-address boundaries (multiple of 4):
```txt
0  mov ax,5
3  nop      ; alligns next instruction
4  add ax,8
```
- x86 processors are designed to load code and data more quickly from even-doubleword addresses.

 ---
## Intel instructions
- **Assembled into machine code by assembler and executed at runtime by CPU.**
- **An instruction contains:**
	- Label => (Optional)
	- Mnemonic => (Required)
	- Operands => (Depends on the instruction)
	- Comment => (Optional) begins with a ';' 

```txt
[label:] mnemonic [operands] [;comment]

loop1: 
mov eax,32 ; this is a comment
```
---
# Basic data types
1. `BYTE`, `SBYTE`: 8-bit unsigned & signed integers.
2. `WORD`, `SWORD`: 16-bit unsigned & signed integers.
3. `DWORD`, `SDWORD`: 32-bit unsigned & signed integers.
4. `QWORD`: 64-bit integer. => (Not signed/unsigned)
5. `TBYTE`: 80-bit integer. => (ten byte)
6. `REAL4`, `REAL8`: 4-byte & 8-byte long reals.
7. `REAL10`: 10-byte IEEE extended real.
## Legacy data directives
1. `DB`: 8-bit integer.
2. `DW`: 6-bit integer.
3. `DD`:  32-bit integer or real.
4. `DQ`: 64-bit integer or real.
5. `DT`: 80-bit integer. => (ten bytes).

## Data definition statement
1. A data definition statement sets aside storage in memory for a variable.
2. May optionally assign a name (label) to the data.
- **Syntax**
![[variable statement.png]]
3. Use the `?` symbol for undefined variables.
4. All initializers become binary data in memory.
## Defining BYTE, SBYTE data
- **Each of the following defines a single byte of storage.**
1. `Value1 BYTE 'A'` => character constant.
2. `Value2 BYTE 0` => smallest unsigned byte. 
3. `Value3 BYTE 255` => largest unsigned byte.
4. `Value4 SBYTE -128` =>smallest signed byte.
5. `Value5 SBYTE +127` =>largest signed byte.
6. `value6 BYTE ?` => uninitialized byte.
- The optional name is label marking the variable's offset from the beginning of it's enclosing segment.
- If value1 is located at `offset 0000` in the data segment and consumes 1 byte of storage, value2 is automatically located at `offset 0001`
- If you declare a `SBYTE` variable, the microsoft debugger will automatically display it's value in decimal with a leading sign.
## Defining Byte Arrays
![[offset.png]]
1. An array is simply a set of sequential memory locations.
2. The directive (BYTE) indicates the offset needed to get to the next array element.
3. No length, no termination flag, no special properties.
## Defining strings
- A string is implemented as a sequence of characters.
	1. For convenience, it's usually enclosed in quotation  marks.
	2. It's usually null terminated.
	3. Characters are bytes.
	4. Hex characters `0Dh`(CR) and `0Ah`(LF) are useful.
- **Example**
![[define strings.png]]
---
# References
1. [Brief Introduction to NASM]( https://montcs.bloomu.edu/Information/LowLevel/Assembly/assembly-tutorial.html)
2. [Nasm tutorial](https://cs.lmu.edu/~ray/notes/nasmtutorial/)