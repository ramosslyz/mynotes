# ASM basics
---
## Navigation

- **[[#Intel instructions]]**
- **[[#Basic data types]]**
	1. [[#Legacy data directives]]
	2. [[#Data definition statement]]
	3. [[#Defining BYTE SBYTE data]]
	4. [[#Defining Byte Arrays]]
	5. [[#Defining strings]]
- **[[#Instructions]]**
	- **[[#Operand types]]**
		- [[#Operand notation]]
	- **[[#MOV instruction]]**
		- [[#MOV errors]]
		- [[#Zero extension]]
		- [[#Sign extension]]
	- **[[#XCHG instruction]]**
	- **[[#Examples]]**
		- [[#Example 2]]
- **[[#References]]**
---
# Basic elements
1. **[[#Integer constants and expressions]]**
2. **[[#Character and string]]**
3. **[[#Reserved words and identifiers]]**
4. **[[#Directives موجه]]**
5. **[[#Labels]]**
6. **[[#Mnemonic]]**

![[Nasm structure.png]]

## Integer constants and expressions.
- Optional leading `+` or `-` sign.
- Binary, Decimal, Hexadecimal.
- Common radix characters:
	- `h` => hexadecimal  (Use as much as possible)
	- `d` => Decimal  (When hex makes no sense)
	- `b` => Binary  (For bitwise clarity)
	- `r` => Encoded real  (Real)
**Examples:**
`30d`, `6Ah`, `42`, `1101b`

>**NOTE:** Hexadecimal can't begin with a letter. => 0A2h

### Expressions
As any programming language
```txt
(2*3) + 4/6
```
---
## Character and string
- **Enclose character in single or double quotes.**
	-  `'a'` , `"a"`  => (ASCII char == 1 byte).
- **Enclose strings in single or double quotes.**
	- `"Hello"` , `'Hello'` => (Each ASCII char == 1 byte).
- **Embedded quotes are allowed**
	- `'Say "Abuqasem" is learning'`
	- `"This isn't  a test"`

> **NOTE:**
> Each string must end with a  '0' to tell the function to print until the zero.
> => "Hello world",0 (old assemblers used '$' instead of zero)

---
## Reserved words and  identifiers
- **Reserved words cannot be used as identifiers.**
	- Instruction mnemonics, directives,  type attributes, operators, predefined symbols.
- **Identifiers**
	- 1-247 chars, including digits.
	- Not case sensitive.
	- First character must be a letter. => (`_`, `@`, `?`, `$`)
	- Used for labels (Procedure names, variables, constants).
---
## Directives (موجه)
- **Instructions on how to assemble (Not at runtime).**
- **Commands that are recognized ad acted upon by the assembler.**
	- Not part of the intel instruction set.
	- Used to declare code , data areas, select memory model, declare procedures, variables etc..
	- Not case sensitive (.data,.DATA,.DAta).
- **Different assemblers have different directives**
	- GNU , netwide are not the same as MASM.
- **One important function of assembler directives is to define program sections, or segments**
	- .data (define variables)
	- .code (write code)
	- .stack 100h
 ---
 ## Labels
 - **Act as a place markers**
 	- Marks the address (offset) of code ad data.
 - **Follow identifier rules**
 - **Data label (Variable names)**
 	- Must be unique.
 	- `count DWORD 100` => (not followed by a colon)
 - **Code label**
 	- Target of jump and loop instructions.
 	- `L1:`  => (Followed by a colon)
 --- 
 ## Mnemonic
 - **No operands**
 	- `stc` => (set carry flag)
 - **One operand**
 	- `inc eax` => (register)
 	- `inc myByte` => (memory)
 - **Two operands**
 	- `add ebx,ecx` => (register, register)
 	- `sub myByte,25` => (memory, constant)
 	- `add eax,36 * 25` => (register, const-expr)

### NOP instruction
- No Operation.
- Uses 1 byte of storage.
- CPU: Reads it, Decodes it, ignores it.
- Used to allign code to even-address boundaries (multiple of 4):
```txt
0  mov ax,5
3  nop      ; alligns next instruction
4  add ax,8
```
- x86 processors are designed to load code and data more quickly from even-doubleword addresses.

 ---
## Intel instructions
- **Assembled into machine code by assembler and executed at runtime by CPU.**
- **An instruction contains:**
	- Label => (Optional)
	- Mnemonic => (Required)
	- Operands => (Depends on the instruction)
	- Comment => (Optional) begins with a ';' 

```txt
[label:] mnemonic [operands] [;comment]

loop1: 
mov eax,32 ; this is a comment
```
---
# Basic data types
1. `BYTE`, `SBYTE`: 8-bit unsigned & signed integers.
2. `WORD`, `SWORD`: 16-bit unsigned & signed integers.
3. `DWORD`, `SDWORD`: 32-bit unsigned & signed integers.
4. `QWORD`: 64-bit integer. => (Not signed/unsigned)
5. `TBYTE`: 80-bit integer. => (ten byte)
6. `REAL4`, `REAL8`: 4-byte & 8-byte long reals.
7. `REAL10`: 10-byte IEEE extended real.
## Legacy data directives
1. `DB`: 8-bit integer.
2. `DW`: 6-bit integer.
3. `DD`:  32-bit integer or real.
4. `DQ`: 64-bit integer or real.
5. `DT`: 80-bit integer. => (ten bytes).

## Data definition statement
1. A data definition statement sets aside storage in memory for a variable.
2. May optionally assign a name (label) to the data.
- **Syntax**
![[variable statement.png]]
3. Use the `?` symbol for undefined variables.
4. All initializers become binary data in memory.
## Defining BYTE, SBYTE data
- **Each of the following defines a single byte of storage.**
1. `Value1 BYTE 'A'` => character constant.
2. `Value2 BYTE 0` => smallest unsigned byte. 
3. `Value3 BYTE 255` => largest unsigned byte.
4. `Value4 SBYTE -128` => smallest signed byte.
5. `Value5 SBYTE +127` => largest signed byte.
6. `value6 BYTE ?` => uninitialized byte.
- The optional name is label marking the variable's offset from the beginning of it's enclosing segment.
- If value1 is located at `offset 0000` in the data segment and consumes 1 byte of storage, value2 is automatically located at `offset 0001`
- If you declare a `SBYTE` variable, the microsoft debugger will automatically display it's value in decimal with a leading sign.
## Defining Byte Arrays
![[offset.png]]
1. An array is simply a set of sequential memory locations.
2. The directive (BYTE) indicates the offset needed to get to the next array element.
3. No length, no termination flag, no special properties.
## Defining strings
- A string is implemented as a sequence of characters.
	1. For convenience, it's usually enclosed in quotation  marks.
	2. It's usually null terminated.
	3. Characters are bytes.
	4. Hex characters `0Dh`(CR) and `0Ah`(LF) are useful.
- **Example**
![[define strings.png]]

---
# Instructions
## Outline
1. **Data Transfer Instructions**
	- Operand types
	- `MOV`, `MOVZX`, `MOVSX`
	- `LAHF`, `SAHF`
	- `XCHG`
2. **Addition and Subtraction**
	- `INC`, `DEC`
	- `ADD`, `SUB` 
	- `NEG`
3. **Data-related operators and directives**
4. **Indirect addressing**
5. `JMP`, `LOOP`

## Operand types
1. Immediate (constant integer(8,16,32 bits))
2. Register (the name of register)
3. Memory (reference to location in memory)
	- Memory address is encoded with the instruction, or a register holds the address of a memory location
```txt
.data
	var1 BYTE 10h
;suppose var1 were located at offset 10400h
MOV AL,var1 ; AL 00010400
```
### Operand notation
![[operand notation.png]]
## MOV instruction
1. Move from source to destination
	- `MOV destination, source`
2. Both operands must be the same size.
3. **No more** than one memory operand permitted.
4. `CS`, `EIP`, `IP` **cannot** be the destination.
5. **No immediate** to segment registers moves.
6. To `MOV` memory to memory.
```txt
.code
	MOV AX,var1
	MOV var2,AX
```
7. Direct memory operands
```txt
.data
	var1 BYTE 10h
.code
	MOV AL, var1 ; AL = 10h
	MOV AL,[var1] ; AL = 10h 
	
; Use it only when an arithmetic expression is involved
MOV AL, [var1 + 5]
```
### MOV errors
```txt
.data
	bVal 	BYTE 	100
	bVal2 	BYTE 	?
	wVal 	WORD 	2
	dVal 	DWORD 	5

.code
	MOV AL,wVal		; byte <- word
	MOV AX,bVal		; word <- byte
	MOV EAX,bVal	; dword <- byte
	MOV DS,45		; immediate value not permitted
	MOV EIP,dVal	; invalid destination (EIP)
	MOV 25,bVal		; invalid destination (25)
	MOV bVal2,bVal	; move in mem not permitted
```
### Zero extension
- When you copy a smaller value into a larger destination, the `MOVZX` instruction fills (extends) the upper half of the destination with zeros.
![[zeroext.png]]
### Sign extension
- The `MOVSX` instruction fills the upper half of the destination with a copy of the source operand's sign bit.
![[signext.png]]
## XCHG instruction
1. XCHG exchanges the values of two operands.
2. At least **one operand** must be a register.
3. No immediate operands are permitted.
```txt
.data
	var1 WORD 1000h
	var2 WORD 2000h

.code
	XCHG AX,BX		; exchange 16-bit regs
	XCHG AH,AL		; exchange 8-bit regs
	XCHG var1,BX	; exchange mem, reg
	XCHG EAX,EBX	; exchange 32-bit regs
	
	XCHG var1,var2	; Error: two memory operands
```
## Examples
```txt
.data
	arrayW	WORD 1000h,2000h,3000h
	arrayD	DWORD 1,2,3,4
	
.code
	MOV AX,[arrayW+2]	; AX = 2000h
	MOV AX,[arrayW+4]	; AX = 3000h
	MOV AX,[arrayW+6]	; EAX = 000000002h
	MOV EAX,[arrayD+4]
	
	MOV AX,[arrayD-2]	; AX = 3000h
	MOV EAX,[arrayD+20]	; Possible seg fault!
```
> 1. There is no "range checking" - the address is calculated and used.
> 2. Size of transfer is based on the destination.

### Example 2
- Write a program that adds the following three bytes:
```txt
.data
	myBytes	BYTE 80h,66h,0A5h
	
.code
	MOV AL,myBytes
	ADD AL,[myBytes+1]
	ADD AL,[myBytes+2]
```
---
# References
1. [Brief Introduction to NASM]( https://montcs.bloomu.edu/Information/LowLevel/Assembly/assembly-tutorial.html)
2. [Nasm tutorial](https://cs.lmu.edu/~ray/notes/nasmtutorial/)